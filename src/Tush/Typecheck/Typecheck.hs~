{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}

module Tush.Typecheck.Typecheck where

import ClassyPrelude

import Tush.Parse.Syntax

import qualified Data.Map as M

-- import Control.Monad.State

type LocalTypes = M.Map (Var ()) BuiltinType

-- newtype TypeCheck s a = TypeCheck { runTypeCheck :: State s a } deriving (Functor, Applicative, Monad, MonadState s)

typecheckCall :: Expression () -> LocalTypes -> BuiltinType
typecheckCall (CallE (VarE name _) args _) lt = case M.lookup name lt of
  Nothing -> error $ "ERROR: TYPEINFERENCE: Unknown function: `" ++
             show name ++
             "'."
  Just t -> case t of
    BTLambda returnType declaredTypes ->
      let actualTypes = (\x -> typecheck x lt) <$> args in
      if declaredTypes == actualTypes then
         returnType -- all is good!
      else
        error $ "ERROR: TYPEINFERENCE: Cannot unify declared arg types `" ++
        show declaredTypes ++
        "' with actual types `" ++
        show actualTypes ++
        "'."
    _ -> error $ "ERROR: TYPEINFERENCE: Cannot call non-Lambda value: `" ++
         show name ++
         "'.  Expected Lambda type but actual type is: `" ++
         show t ++
         "'."
typecheckCall e _ = error $ "ERROR: COMPILERERROR: Tried to call `typeCheckCall' on non-CallE: `" ++
                    show e ++
                    "'."

typecheckIf :: Expression () -> LocalTypes -> BuiltinType
typecheckIf i@(IfE cond conse anted _) lt
  | typecheck cond lt /= BTBool = error $ "ERROR: TYPEINFERENCE: Cannot unify type `" ++
                                  show (typecheck cond lt) ++
                                  "' with type Boolean.  (In the Conditional of the If expression `" ++
                                  show i ++
                                  "'.)"
  | typecheck conse lt /= typecheck anted lt = error $ "ERROR: TYPEINFERENCE: Cannot unify type `" ++ 
                                               show (typecheck conse lt) ++ 
                                               "' with type `" ++ 
                                               show (typecheck anted lt) ++
                                               "'.  (The types of the branches of the If Expression `" ++ 
                                               show i ++ 
                                               "' do not match.)"
  | otherwise = typecheck conse lt
typecheckIf e _ = error $ "ERROR: COMPILERERROR: Tried to `typeCheckIf' on non-IfE `" ++
                  show e ++
                  "'."

typecheck :: Expression () -> LocalTypes -> BuiltinType
typecheck (LitE (BLit _) _) _ = BTBool
typecheck (LitE (FLit _) _) _ = BTFloat
typecheck (LitE (ILit _) _) _ = BTInt
typecheck b@(BinOpE op l r _) lt 
  | typecheck l lt /= typecheck r lt = error $ "ERROR: TYPEINFERENCE: Cannot unify type `" ++ 
                                       show (typecheck l lt) ++ 
                                       "' with type `" ++ 
                                       show (typecheck r lt) ++
                                       "'.  In Expression: `" ++ 
                                       show b ++ 
                                       "'."
  -- TODO: Fix the binops that are bool only.
  | op == Lt = BTBool
  | otherwise = typecheck l lt
typecheck (UnOpE _ x _) lt = typecheck x lt
typecheck (VarE v _) lt = case M.lookup v lt of
  Nothing -> error $ "ERROR: TYPEINFERENCE: Unknown variable: `" ++
             show v ++
             "'."
  Just t -> t
typecheck c@(CallE _ _ _) lt = typecheckCall c lt
typecheck i@(IfE _ _ _ _) lt = typecheckIf i lt


simpleTag :: Expression () -> LocalTypes -> Expression BuiltinType
simpleTag (LitE (BLit x) _) _ = LitE (BLit x) BTBool
simpleTag (LitE (FLit x) _) _ = LitE (FLit x) BTFloat
simpleTag (LitE (ILit x) _) _ = LitE (ILit x) BTInt
simpleTag b@(BinOpE op x y _) lt = BinOpE op (simpleTag x lt) (simpleTag y lt) (typecheck b lt)
simpleTag u@(UnOpE op x _) lt = UnOpE op (simpleTag x lt) (typecheck u lt)
simpleTag v@(VarE (Var name _) _) lt = VarE (Var name (typecheck v lt)) (typecheck v lt)
simpleTag c@(CallE name args _) lt = CallE (simpleTag name lt) ((\x -> simpleTag x lt) <$> args) (typecheck c lt)
simpleTag i@(IfE cond conse ante _) lt = IfE (simpleTag cond lt) (simpleTag conse lt) (simpleTag ante lt) (typecheck i lt)

simplyTypedVarToLocalTypePair :: SimplyTypedVar -> (Var (), BuiltinType)
simplyTypedVarToLocalTypePair stv = (Var (varName stv) (), varInfo stv)

constructLocalTypesFromFProto :: FProto BuiltinType -> LocalTypes
constructLocalTypesFromFProto (FProto name args) = M.fromList $ (simplyTypedVarToLocalTypePair name) : 
                                                                toList (simplyTypedVarToLocalTypePair <$> args)

-- | THIS IS SEMANTICALLY WRONG!!! It makes local variables visible
-- outside of their functions for nested functions!!
constructLocalTypes :: Statement () BuiltinType -> LocalTypes
constructLocalTypes (ExprS _) = mempty
constructLocalTypes (ExternS (FProto name _)) = M.singleton (fst lp) $ snd lp
  where
    lp = simplyTypedVarToLocalTypePair name
constructLocalTypes (FuncS fp xs) = concat $ cons funcLocals $ constructLocalTypes <$> xs
  where
    funcLocals = constructLocalTypesFromFProto fp
